##描述表的概念
什么是描述表，广义来讲就是对被描述者内在特征的一种表述形式。对于
放在json的环境下看就是对用json组织的数据结构所具有的数据间的内在特征的表述形式。
##描述表的优势

利用描述表来管理底层数据实体，就是用抽象的概念来管理具体的数据。
```var users= [A,B,C]```，这段代码创建了一个使用者的数组，而实际上这种表达方式暴露了太多底层的行为和机制，var 是什么，如果不看users我们根本不知道A,B,C又代表什么。如果加上注释或者用自然语言来表达我们就是想说我们创建了三个玩家，仅此而已。
暴露对应业务层所需要看到的代码，屏蔽它的底层实现，这是描述表最大的特征。
以上业务用nojson表述为"@?users=@user*3" 取出含有三个user型的users型数据,如果未定义就现定义。
事实上你可以直接用@users来代替上面一段话，?只是帮你带出了语言环境，如果一个人不知道users的概念，他可以提问，因此我们进一步回答users是什么。
当然这样一个人说的users和其他人说的users可能不是一个概念,这里我们特指users为玩家,而其他一些时候users是操作员。
```define @users @game @name
表示你要用到的这些型来自于外部已经定义好的,你可以在程序中直接引用他们，如果给他们添加了临时的语境使用?users=这种形式临时创建语义，则表示临时创建了一个相同的概念而已。这与不在头部声明@users还是有所区别的，@和?在define语境下合并使用和单独使用的区别对照。

以下以users为例

序号|define	 | @ |   ?  |   行为|语言实践(伪代码)|最佳实践
:-::-----------: | :-----------: | :-----------:|:----|:----|:----
1|X|O|X|引用一个型 如果不存在则创建一个空型并命名为users|```if(users!=null){users = new Object()}users.startGame()```
2|X|X|O| 判断一个型是否存在,若不存在则报错或者返回false(视语境决定其行为)或用=后面的描述为其定义|```if(users === undefined){case 1:throws Exception;case 2:return false;case 3:users = [1101@user,1102@user,1103@user]```
3|X|O|O|引用一个已存在的型，若不存在则用=后面的描述为其定义并引用之,否则返回@false或@cast
4|O|O|X|引用外部定义的型users
5|O|X|O|局部定义型users或直接返回false或抛出异常相当于返回常量@false或@cast||一般用于判断是否有相同的外部定义
6|O|O|O|


只不过他们的背后可能代表一些数据返回，一些变量，或者一些操作。
时候只需要就是描述了一个数据结构首先来看看我们的编程行为，面向对象的编程语言会先定义一个类，类的概念就是一个描述，描述一段程序在它运行的时候大概它有什么样的方法，有什么样的属性有什么样的外在行为，之所以我们更多关注类，就是因为实际运行的对象实体有太多太多一致的行为需要抽象，

##nojson从左至右表述法
###结构型从属原则
从左到右可以表示并列、递进或者从属，那么同自然语言一样，描述表总是从左到右表述，不同的是当遇到状语和定语这种“A的B的C”句式的时候，我们将其倒装还原成为动宾模式，“C有一个B，B有一个A”，这样每一层与上一层构成了一种从属关系，也就是下一层的语意是建立在上一层基础上的，每一级都有描述的主体或显式或隐式，解释成编程语言也就是预先声明了默认的被操作对象，也就是很多语言当中的this关键字，换言之就是语句中的人称代词。
如何用nojson表述法描述如下需求呢？

	选出一个没有手牌的角色
	
	@user[..@users[@hand_region[==0]]


从左到右我们先定义了一个user型，这是我们最终要的结果,也就是整个自然语言的定语，前面所有的条件都是状语(请先忽略动词“选出“，此时你可以理解其为“被选出的”)，
经过一层语言处理之后我们发现原来的表述变成了

	有一个角色[他是被选出的没有手牌的那个]
	
在语言实现中我们给他设置一个临时变量 var user_temp:Person = null;user_temp是实际对象，Person在强类型语言中只是说明他是一个人而不是鸭子或者是桌子。

除此之外，user型需要满足如下特征：他是从父级users型中条件查询得到的，此处我们补充了原有描述“他是被选出来”的语境。

	有一个角色[他从所有玩家中被选出来[他没有手牌]]
	

当我们再次进行模糊查询的时候语境已经从@user这个未知的待查找的角色跳到了@users这个已知的具有@user子型的具体结构当中。
###条件查询式的从左到右表述法
此时我们继续向下寻找手牌这个型@hand_region它在[]中表示它只是一个查询条件，通常在内部查找时我们会去@users这个型的描述表中直接查询@hand@region关键字，因为根据从属原则，右边的型总是被包含于左边的型，如果@users型描述表中根本没有@hand@region那么后面的描述因为缺失了主体也都变得毫无意义，条件将返回false并一层层跳出条件表达式，从左到右的阅读理解和从右到左的执行正好对应函数调用和返回，最右边的条件表达式[==0]因为上一个型查询失败而得不到执行，条件查询式的从左到右表述法实际包含了多重if return条件嵌套以及函数嵌套 而else只作为默认输出一般返回false或抛出异常。
###结构型和条件式的模式统一
由于结构型和条件式都可以从左到右表示，结构型又可以通过定义来进行代替查询式，因此在单一的以结构型作为查询的情况简写为偏序关系[忽略中括号直接从左至右书写]。
而在只有一层父子关系下具有绝对的简洁性，所以@hand_region作为一种约定表示的就是@hand[@region]包含@region的@hand型只有在没有@hand和@region这种极少情况下才将其看做一个单一的型名。
##描述表的多级特性
描述表具有多个层级，每一级只对本层深度进行详细描述，并对下级进行摘要描述，这与结构型的从左至右表示法相吻合。例如上面的例子实际上是一个结构型的倒装，还原成@users描述表中的一段就是@users@user
##描述表的折叠处理
利用描述表处理数据的核心思想就是字符串比较，通过正则查找快速定位，通过正则替换快速修改，但是未经进化的描述表并不能够利于正则查找，一些操作符或型内置了描述表的预处理，我们称之为折叠处理。例如集体忽略@后面的？，以及集体忽略条件查询语句[]内的干扰项等等。
最重要的一点是，通过折叠我们可以处理一些非常复杂的查找。
比如上边的例子我们可以查找所有含有牌区且为空的情况。

	[@region[==0]]
	
在处理这样一个条件查询的时候除了常规的查询操作外我还定义了一种折叠算法

	@collapse = "...@region[==0]"
忽略最外层的[]以及@region前面的内容,使得省略中括号的简写写法和所有包含@region的父级都得到了查找
由于本身包含查询和折叠则我将其命名为新的型以便后来复用。

	?nocard = [@region[==0]]&@collapse= "...@region[==0]"
	
这样原来的查询就变成了去掉[]的更接近自然语言的表示法了

	@user..@users@hand@nocard
更复杂的折叠采用了代换的思维。具体折叠算法表示法还在研究之中。


##描述表的进化特性
程序启动之初，描述表只是一张包含有描述原始数据的偏序表,除了全局define的型和基本型,以及在解析时确定的型和关系,并不包含任何用户定义的行为，随着用户执行nojson表示法加入众多查询和自定义型的行为，每一次耗时的多表联查和对表的预处理块最终会替换原始偏序序列串，形成快表。快表会加快对应表达式的查询速度，形成一次性查询和取出数据。
描述表的进化特性具有专一性，即只对一种特定状态起到了加快作用，整体代换思想加快了部分查询却另其他查询更加缓慢，未来的进化思路有两个：

	1.全部查询都使用进化。根据每种进化设置多张块表。
	2.在少量快表上根据运行时权重过滤一部分查询，

##描述表的优势
提到描述表的优势，不得不提描述表的概念究竟是什么。
描述表是一个中间产物，它很轻松地在被管理者和管理者之间搭建了一个桥梁，把管理者的意图最终转换为机器行为，在传统IT领域一直由高级编程语言来担当。然而高级语言仍旧是代码，和自然语言想去甚远。

我们最终的目标是用类似于自然语言的描述来定义一系列行为，需求，取出需要的数据，改变他们或利用他们为我们服务。而我们不需要在这种表述中有任何专业语言的掺杂，比如循环，声明，抛出异常，这些概念在业务层面本来就不曾发生。






##描述表的描述范围

描述表描述json结构的哪些内容

##描述表的特征
###1.分层描述
描述表是分层结构
一次解析 历次分析

