##描述表的概念
什么是描述表，广义来讲就是对被描述者内在特征的一种表述形式。对于
放在json的环境下看就是对用json组织的数据结构所具有的数据间的内在特征的表述形式。
##描述表的优势

利用描述表来管理底层数据实体，就是用抽象的概念来管理具体的数据。
```var users= [A,B,C]```，这段代码创建了一个使用者的数组，而实际上这种表达方式暴露了太多底层的行为和机制，var 是什么，如果不看users我们根本不知道A,B,C又代表什么。如果加上注释或者用自然语言来表达我们就是想说我们创建了三个玩家，仅此而已。
暴露对应业务层所需要看到的代码，屏蔽它的底层实现，这是描述表最大的特征。
以上业务用nojson表述为"@?users=@user*3" 取出含有三个user型的users型数据,如果未定义就现定义。
事实上你可以直接用@users来代替上面一段话，?只是帮你带出了语言环境，如果一个人不知道users的概念，他可以提问，因此我们进一步回答users是什么。
当然这样一个人说的users和其他人说的users可能不是一个概念,这里我们特指users为玩家,而其他一些时候users是操作员。
```define @users @game @name
表示你要用到的这些型来自于外部已经定义好的,你可以在程序中直接引用他们，如果给他们添加了临时的语境使用?users=这种形式临时创建语义，则表示临时创建了一个相同的概念而已。这与不在头部声明@users还是有所区别的，@和?在define语境下合并使用和单独使用的区别对照。

以下以users为例

序号|define	 | @ |   ?  |   行为|语言实践(伪代码)|最佳实践
:-::-----------: | :-----------: | :-----------:|:----|:----|:----
1|X|O|X|引用一个型 如果不存在则创建一个空型并命名为users|```if(users!=null){users = new Object()}users.startGame()```
2|X|X|O| 判断一个型是否存在,若不存在则报错或者返回false(视语境决定其行为)或用=后面的描述为其定义|```if(users === undefined){case 1:throws Exception;case 2:return false;case 3:users = [1101@user,1102@user,1103@user]```
3|X|O|O|引用一个已存在的型，若不存在则用=后面的描述为其定义并引用之,否则返回@false或@cast
4|O|O|X|引用外部定义的型users
5|O|X|O|局部定义型users或直接返回false或抛出异常相当于返回常量@false或@cast||一般用于判断是否被定义
6|O|O|O|


只不过他们的背后可能代表一些数据返回，一些变量，或者一些操作。
时候只需要就是描述了一个数据结构首先来看看我们的编程行为，面向对象的编程语言会先定义一个类，类的概念就是一个描述，描述一段程序在它运行的时候大概它有什么样的方法，有什么样的属性有什么样的外在行为，之所以我们更多关注类，就是因为实际运行的对象实体有太多太多一致的行为需要抽象，

##nojson从左至右表述法
同自然语言一样，描述表总是从左到右表述，这样每一层级都有描述的主体，解释成语言也就是默认的被操作对象，相当于this，也就是语言中的人称代词。而执行顺序却是从右到左。
如何用nojson表述法描述如下需求呢？

	选出一个没有手牌的角色
	
```@user[^@users[@hand_region[==0]]```

从左到右我们先定义了一个user型，这是我们最终要的结果,也就是整个自然语言的定语，前面所有的条件都是状语(请先忽略动词“选出“，此时你可以理解其为“被选出的”)，在语言实现中我们给他设置一个临时变量 var user_temp:User = null;

user型需要满足如下特征它是从父级users型中条件查询得到的，此处我们补充了原有描述“选出一个角色”的语境。

当我们再次进行模糊查询的时候语境已经从@user这个未知的待查找的角色跳到了@users这个已知的具有@user子型的具体结构当中。
###条件查询式的从左到右表述法
此时我们继续向下寻找手牌这个型@hand_region它在[]中表示它只是一个查询条件，通常在内部查找时我们会去@users这个型的描述表中直接查询@hand@region关键字，因为根据从属原则，右边的型总是被包含于左边的型，如果@users型描述表中根本没有@hand@region那么后面的描述因为缺失了主体也都变得毫无意义，条件将返回false并一层层跳出条件表达式，从左到右的阅读理解和从右到左的执行正好对应函数调用和返回，最右边的条件表达式[==0]因为上一个型查询失败而得不到执行，但是却阅读知道了他一定是要能被执行到的，在词法分析构建过程中他的执行代码生成了如下：
###结构型的从左至右表示法
```
###构建可伸缩的执行代码

就是表示法中的偏序和函数嵌套。因为@hand_region作为一种约定表示的就是@hand[@region]包含@region的@hand型
##描述表的多级特性
描述表具有多个层级，每一级只对本层深度进行详细描述，并对下级进行摘要描述，这与结构型的从左至右表示法相吻合。例如上面的例子实际上是一个结构型的倒装，还原成@users描述表中的一段就是@users@user
##描述表的折叠处理
利用描述表处理数据的核心思想就是字符串比较，通过正则查找快速定位，通过正则替换快速修改，但是未经进化的描述表并不能够利于正则查找，一些操作符或型内置了描述表的预处理，我们称之为折叠处理。例如集体忽略@后面的？，以及集体忽略条件查询语句[]内的干扰项等等。

##描述表的进化特性
程序启动之初，描述表只是一张包含有描述原始数据的偏序表,除了全局define的型和基本型,以及在解析时确定的型和关系,并不包含任何用户定义的行为，随着用户执行nojson表示法加入众多查询和自定义型的行为，每一次耗时的多表联查和对表的预处理块最终会替换原始偏序序列串，

##描述表的优势
提到描述表的优势，不得不提描述表的概念究竟是什么。
描述表是一个中间产物，它很轻松地在被管理者和管理者之间搭建了一个桥梁，把管理者的意图最终转换为机器行为，在传统IT领域一直由高级编程语言来担当。然而高级语言仍旧是代码，和自然语言想去甚远。

我们最终的目标是用类似于自然语言的描述来定义一系列行为，需求，取出需要的数据，改变他们或利用他们为我们服务。而我们不需要在这种表述中有任何专业语言的掺杂，比如循环，声明，抛出异常，这些概念在业务层面本来就不曾发生。






##描述表的描述范围

描述表描述json结构的哪些内容

##描述表的特征
###1.分层描述
描述表是分层结构
一次解析 历次分析

